#! /usr/bin/env python
# coding=utf-8

__version__ = "1.4.3"

import sys
from os import path, chdir
from subprocess import Popen, PIPE


class GitArchiver(object):
    """
    GitArchiver

    Scan a git repository and export all tracked files, and submodules.
    Checks for .gitattributes files in each directory and uses 'export-ignore'
    pattern entries for ignore files in the archive.

    Automatically detects output format extension: zip, tar, bz2, or gz.
    """

    def __init__(self, prefix='', verbose=False, exclude=True, force_sub=False, extra=None, main_repo_abspath=None):
        if extra is None:
            extra = []

        if main_repo_abspath is None:
            main_repo_abspath = path.abspath('')
        elif not path.isabs(main_repo_abspath):
            raise ValueError("You MUST pass absolute path to the main git repository.")

        self.prefix = prefix
        self.verbose = verbose
        self.exclude = exclude
        self.extra = extra
        self.force_sub = force_sub
        self.main_repo_abspath = main_repo_abspath

    def create(self, output_file_path):
        """
        create(str output_file_path) -> None

        Creates the archive, written to the given output_file_path
        Filetype may be one of:  gz, zip, bz2, tar, tgz
        """
        #
        # determine the format
        #
        _, _, format = output_file_path.rpartition(".")
        format = format.lower()

        if format == 'zip':
            from zipfile import ZipFile, ZIP_DEFLATED
            output_archive = ZipFile(path.abspath(output_file_path), 'w')
            add = lambda name, arcname: output_archive.write(name, self.prefix + arcname, ZIP_DEFLATED)

        elif format in ['tar', 'bz2', 'gz', 'tgz']:
            import tarfile

            if format == 'tar':
                t_mode = 'w'
            elif format == 'tgz':
                t_mode = 'w:gz'
            else:
                t_mode = ('w:%s' % format)

            output_archive = tarfile.open(path.abspath(output_file_path), t_mode)
            add = lambda name, arcname: output_archive.add(name, self.prefix + arcname)
        else:
            raise RuntimeError("Unknown format: '%s'" % format)

        #
        # compress
        #

        # extra files first (we may change folder later)
        for name in self.extra:
            if self.verbose:
                to_path = '=> %s%s' % (self.prefix, name) if self.prefix else ""
                print 'Compressing %s %s ...' % (name, to_path)
            add(name, name)

        for name, arcname in self.list_files():
            if self.verbose:
                to_path = '=> %s%s' % (self.prefix, arcname) if self.prefix else ""
                print 'Compressing %s %s ...' % (arcname, to_path)
            add(name, arcname)

        output_archive.close()

    def dry_run(self):
        """
        Does nothing but prints what would be done.
        """
        for file_path in self.extra:
            print "{file_path} => {arc_file_path}".format(file_path=file_path, arc_file_path=path.join(self.prefix, file_path))

        for file_path, arc_file_path in self.list_files():
            print "{file_path} => {arc_file_path}".format(file_path=file_path, arc_file_path=path.join(self.prefix, arc_file_path))

    def get_path_components(self, repo_abspath, abspath):
        """
        Splits given abspath into components until repo_abspath is reached.
        """
        components = []
        while not path.samefile(abspath, repo_abspath):
            abspath, tail = path.split(abspath)
            if len(tail):
                components.insert(0, tail)
        components.insert(0, path.relpath(repo_abspath, repo_abspath))
        return components

    def get_exclude_patterns(self, repo_abspath, repo_file_paths):
        """
        Returns exclude patterns for a given repo.
        It looks for .gitattributes files in repo_file_paths.
        """
        if not self.exclude:
            return None

        def read_attributes(attributes_abspath):
            patterns = []
            if path.isfile(attributes_abspath):
                attributes = open(attributes_abspath, 'r').readlines()
                patterns = []
                for line in attributes:
                    tokens = line.strip().split()
                    if 'export-ignore' in tokens[1:]:
                        patterns.append(tokens[0])
            return patterns

        exclude_patterns = {}

        global_attributes_abspath = self.run_shell('git config --get core.attributesfile', repo_abspath).rstrip()
        exclude_patterns[()] = read_attributes(global_attributes_abspath)

        for attributes_abspath in [path.join(repo_abspath, f) for f in repo_file_paths if f.endswith('.gitattributes')]:
            key = tuple(self.get_path_components(repo_abspath, path.dirname(attributes_abspath)))
            exclude_patterns[key] = read_attributes(attributes_abspath)

        local_attributes_abspath = path.join(repo_abspath, '.git', 'info', 'attributes')
        key = tuple(self.get_path_components(repo_abspath, repo_abspath))
        if key in exclude_patterns:
            exclude_patterns[key].extend(read_attributes(local_attributes_abspath))
        else:
            exclude_patterns[key] = read_attributes(local_attributes_abspath)

        return exclude_patterns

    def is_file_excluded(self, repo_abspath, repo_file_path, exclude_patterns):
        """
        Checks whether file at a given path is excluded.

        @type repo_file_path: string
        @param repo_file_path: Relative path to a file within the main git repository.

        @rtype: bool
        @return: True if file should be excluded. Otherwise False.
        """
        if exclude_patterns is None or not len(exclude_patterns):
            return False

        from fnmatch import fnmatch

        file_name = path.basename(repo_file_path)
        components = self.get_path_components(repo_abspath, path.join(repo_abspath, path.dirname(repo_file_path)))

        is_excluded = False
        # We should check all patterns specified in intermediate directories to the given file.
        # At the end we should also check for the global patterns (key '()' or empty tuple).
        while not is_excluded:
            key = tuple(components)
            if key in exclude_patterns:
                patterns = exclude_patterns[key]
                for p in patterns:
                    if fnmatch(file_name, p) or fnmatch(repo_file_path, p):
                        if self.verbose:
                            print 'Exclude pattern matched (%s): %s' % (p, repo_file_path)
                        is_excluded = True

            if not len(components):
                break

            components.pop()

        return is_excluded


    def list_files(self, repo_path=''):
        """
        An iterator method that yields a tuple(repo_file_path, main_repo_file_path)
        for each file that should be included in the archive.
        Skips those that match the exclusion patterns found in
        any discovered .gitattributes files along the way.

        Recurs into submodules as well.

        @type repo_path:    string
        @param repo_path:   Path to the git submodule repository within the main git repository.

        @rtype:     iterator
        @return:    Iterator to traverse tuples representing files in the git repo.
                    The tuple consist of repo_file_path (relative to the cwd) and main_repo_file_path (relative to main_repo_abspath)
        """

        repo_abspath = path.join(self.main_repo_abspath, repo_path)
        repo_file_paths = self.run_shell('git ls-files --cached --full-name --no-empty-directory', repo_abspath).splitlines()
        exclude_patterns = self.get_exclude_patterns(repo_abspath, repo_file_paths)

        for repo_file_path in repo_file_paths:
            repo_file_path = repo_file_path.decode('string_escape').strip('"')  # file path relative to current repo
            file_name = path.basename(repo_file_path)

            # Only list symlinks and files that don't start with git.
            if file_name.startswith('.git') or (not path.islink(repo_file_path) and path.isdir(repo_file_path)):
                continue

            main_repo_file_path = path.join(repo_path, repo_file_path)  # file path relative to the main repo

            if self.is_file_excluded(repo_abspath, repo_file_path, exclude_patterns):
                continue

            # Yield both repo_file_path and main_repo_file_path to preserve structure of the repo.
            yield repo_file_path, main_repo_file_path

        if self.force_sub:
            self.run_shell("git submodule init", repo_abspath)
            self.run_shell("git submodule update", repo_abspath)

        # List files of every submodule.
        for submodule_path in self.run_shell("git submodule --quiet foreach 'pwd'", repo_abspath).splitlines():
            # In order to get output path we need to exclude repository path from submodule_path.
            submodule_path = path.relpath(submodule_path, self.main_repo_abspath)
            for path_tuple in self.list_files(submodule_path):
                yield path_tuple

    @staticmethod
    def run_shell(cmd, cwd=None):
        """
        Runs shell command and returns the output.

        @type cmd:  string
        @param cmd: Command to be executed.

        @rtype:     string
        @return:    String representing command output.
        """
        return Popen(cmd, shell=True, stdout=PIPE, cwd=cwd).stdout.read()


if __name__ == "__main__":
    from optparse import OptionParser

    parser = OptionParser(usage="usage: %prog [-v] [--prefix PREFIX] [--no-exclude] OUTPUT_FILE",
        version="%prog {version}".format(version=__version__))

    parser.add_option('--prefix',
        type='string',
        dest='prefix',
        default='',
        help="Prepend PREFIX to each filename in the archive. OUTPUT_FILE name is used by default to avoid tarbomb.")

    parser.add_option('-v', '--verbose',
        action='store_true',
        dest='verbose',
        help='Enable verbose mode.')

    parser.add_option('--no-exclude',
        action='store_false',
        dest='exclude',
        default=True,
        help="Don't read .gitattributes files for patterns containing export-ignore attrib.")

    parser.add_option('--force-submodules',
        action='store_true',
        dest='force_sub',
        help="Force a git submodule init && git submodule update at each level before iterating submodules.")

    parser.add_option('--extra',
        action='append',
        dest='extra',
        default=[],
        help="Any additional files to include in the archive.")
    parser.add_option('--dry-run',
        action='store_true',
        dest='dry_run',
        help="Donâ€™t actually archive anything, just show what would be done.")

    options, args = parser.parse_args()

    if len(args) != 1:
        parser.error('You must specify exactly one output file')

    output_file_path = args[0]

    if path.isdir(output_file_path):
        parser.error('You cannot use directory as output')

    # avoid tarbomb
    if options.prefix:
        options.prefix = path.join(options.prefix, '')
    else:
        import re
        output_name = path.basename(output_file_path)
        output_name = re.sub('(\.zip|\.tar|\.tgz|\.gz|\.bz2|\.tar\.gz|\.tar\.bz2)$', '', output_name) or 'Archive'
        options.prefix = path.join(output_name, '')

    archiver = GitArchiver(options.prefix,
                           options.verbose,
                           options.exclude,
                           options.force_sub,
                           options.extra)

    try:
        if not options.dry_run:
            archiver.create(output_file_path)
        else:
            archiver.dry_run()
    except Exception, e:
        parser.exit(2, "%s\n" % e)

    sys.exit(0)
